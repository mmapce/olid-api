<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>OLID Batch Tester</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-zinc-950 text-zinc-100 min-h-screen">
  <div class="max-w-4xl mx-auto p-6">
    <header class="mb-6">
      <h1 class="text-2xl font-bold">OLID – Batch Predictor</h1>
      <p class="text-sm text-zinc-400">
        Paste one text per line or upload a CSV with a <code>text</code> column.
        Service: <a id="docs" class="underline" target="_blank">/docs</a>
      </p>
    </header>

    <section class="space-y-3">
      <div class="flex items-center gap-3 flex-wrap">
        <label class="text-sm text-zinc-300 flex items-center gap-2">
          Threshold
          <input id="thr" type="number" step="0.01" min="0" max="1" value="0.50"
                 class="w-24 rounded bg-zinc-900 border border-zinc-800 px-2 py-1">
        </label>
        <input id="file" type="file" accept=".csv,.txt"
               class="text-sm file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-indigo-600 file:text-white">
        <button id="btn" class="px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-500">Predict</button>
        <button id="btnExport" class="px-4 py-2 rounded bg-zinc-800 border border-zinc-700">Export CSV</button>
        <span id="status" class="text-sm text-zinc-400"></span>
      </div>

      <textarea id="input" rows="8" placeholder="Type or paste one text per line..."
        class="w-full rounded-xl bg-zinc-900 border border-zinc-800 p-4 outline-none focus:ring-2 focus:ring-indigo-500"></textarea>
    </section>

    <section id="summary" class="mt-6 hidden">
      <div class="rounded-xl border border-zinc-800 bg-zinc-900 p-4 text-sm">
        <div id="sumText"></div>
      </div>
    </section>

    <section id="tableWrap" class="mt-4 hidden">
      <div class="rounded-xl border border-zinc-800 overflow-auto">
        <table class="min-w-full text-sm">
          <thead class="bg-zinc-900/80 sticky top-0">
            <tr>
              <th class="p-2 text-left">#</th>
              <th class="p-2 text-left">Text</th>
              <th class="p-2 text-left">Prediction</th>
              <th class="p-2 text-left">Prob (foul)</th>
            </tr>
          </thead>
          <tbody id="tbody" class="bg-zinc-900/40"></tbody>
        </table>
      </div>
    </section>
  </div>

<script>
  // If hosted on the same Cloud Run service:
  const API_URL = window.location.origin;
  document.getElementById("docs").href = API_URL + "/docs";

  const el = (id) => document.getElementById(id);
  const input = el("input"), file = el("file"), thr = el("thr");
  const btn = el("btn"), btnExport = el("btnExport"), statusEl = el("status");
  const tbody = el("tbody"), tableWrap = el("tableWrap"), summary = el("summary"), sumText = el("sumText");

  function escapeHTML(s){return s.replace(/[&<>]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}

  // CSV loader: expects a column named 'text'
  file.addEventListener("change", async e => {
    const f = e.target.files[0];
    if(!f) return;
    const txt = await f.text();
    // naive CSV parse for single 'text' column or plain txt lines
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    let texts = [];
    if (lines[0].toLowerCase().includes("text") && lines[0].includes(",")) {
      // headered CSV, find 'text' column
      const headers = lines[0].split(",").map(h=>h.trim().toLowerCase());
      const idx = headers.indexOf("text");
      if (idx >= 0){
        for(let i=1;i<lines.length;i++){
          const cols = lines[i].split(",");
          if(cols[idx]) texts.push(cols[idx].trim());
        }
      }
    } else {
      // treat every line as a text
      texts = lines;
    }
    input.value = texts.join("\n");
  });

  async function predictBatch(texts, threshold){
    const res = await fetch(API_URL + "/predict/batch", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ texts, threshold: parseFloat(threshold) })
    });
    if(!res.ok) throw new Error(await res.text());
    return res.json();
  }

  btn.addEventListener("click", async () => {
    const lines = input.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    if(lines.length === 0){ alert("Please enter at least one line."); return; }

    tableWrap.classList.add("hidden");
    summary.classList.add("hidden");
    statusEl.textContent = "Predicting…";

    try{
      const data = await predictBatch(lines, thr.value || 0.50);
      // render table
      tbody.innerHTML = "";
      let foul=0, proper=0;
      data.results.forEach((r,i)=>{
        const tr = document.createElement("tr");
        const badge = r.prediction===1
          ? '<span class="px-2 py-0.5 rounded text-xs bg-rose-600/20 text-rose-300 border border-rose-700/40">FOUL</span>'
          : '<span class="px-2 py-0.5 rounded text-xs bg-emerald-600/20 text-emerald-300 border border-emerald-700/40">PROPER</span>';
        tr.innerHTML = `
          <td class="p-2 align-top text-zinc-400">${i+1}</td>
          <td class="p-2 align-top">${escapeHTML(lines[i])}</td>
          <td class="p-2 align-top">${badge}</td>
          <td class="p-2 align-top">${Number(r.prob_foul).toFixed(3)}</td>`;
        tbody.appendChild(tr);
        if(r.prediction===1) foul++; else proper++;
      });
      tableWrap.classList.remove("hidden");

      sumText.innerHTML = `Total: <b>${data.results.length}</b> • Proper: <b>${proper}</b> • Foul: <b>${foul}</b> • Threshold: <b>${data.threshold}</b>`;
      summary.classList.remove("hidden");
      statusEl.textContent = "Done";
    }catch(err){
      console.error(err);
      statusEl.textContent = "Error";
      alert("Request failed:\n" + err.message);
    }
  });

  // Export current table to CSV
  btnExport.addEventListener("click", ()=>{
    const rows = [["idx","text","prediction","prob_foul"]];
    const trs = [...tbody.querySelectorAll("tr")];
    if(trs.length===0){ alert("No results to export."); return; }
    trs.forEach(tr=>{
      const tds = tr.querySelectorAll("td");
      rows.push([
        tds[0].innerText,
        tds[1].innerText.replace(/\n/g," ").trim(),
        /FOUL/.test(tds[2].innerText) ? 1 : 0,
        tds[3].innerText
      ]);
    });
    const csv = rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(",")).join("\n");
    const blob = new Blob([csv], {type: "text/csv;charset=utf-8;"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "predictions.csv";
    a.click();
  });
</script>
</body>
</html>
